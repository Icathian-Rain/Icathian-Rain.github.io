<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>mit 6583 lab1E | IcathianRain's Blog</title><meta name="author" content="IcathianRain"><meta name="copyright" content="IcathianRain"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="GODB的Lab1习题 Exercise 1Q： tuple.goAt this point, your code should pass the unit tests in tuple_test.go.  此时，您的代码应该通过 tuple_test.go 中的单元测试。  TupleDesc类型FileType 12345678&#x2F;&#x2F; FieldType is the type of a fie">
<meta property="og:type" content="article">
<meta property="og:title" content="mit 6583 lab1E">
<meta property="og:url" content="https://blog.icathia.icu/2024/01/12/mit-6583-lab1E/index.html">
<meta property="og:site_name" content="IcathianRain&#39;s Blog">
<meta property="og:description" content="GODB的Lab1习题 Exercise 1Q： tuple.goAt this point, your code should pass the unit tests in tuple_test.go.  此时，您的代码应该通过 tuple_test.go 中的单元测试。  TupleDesc类型FileType 12345678&#x2F;&#x2F; FieldType is the type of a fie">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.icathia.icu/images/avatar.jpg">
<meta property="article:published_time" content="2024-01-12T11:32:40.000Z">
<meta property="article:modified_time" content="2024-10-18T16:25:26.929Z">
<meta property="article:author" content="IcathianRain">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="databases">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.icathia.icu/images/avatar.jpg"><link rel="shortcut icon" href="/images/avatar.jpg"><link rel="canonical" href="https://blog.icathia.icu/2024/01/12/mit-6583-lab1E/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mit 6583 lab1E',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-18 16:25:26'
}</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4179705_k5qmnhfql49.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"/><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://fqh.yllhwa.com/js/Meting.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类页</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">IcathianRain's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">mit 6583 lab1E</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类页</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">mit 6583 lab1E</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-12T11:32:40.000Z" title="发表于 2024-01-12 11:32:40">2024-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-18T16:25:26.929Z" title="更新于 2024-10-18 16:25:26">2024-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Knowledge/">Knowledge</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>GODB的Lab1习题</p>
<h1 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h1><h2 id="Q："><a href="#Q：" class="headerlink" title="Q："></a>Q：</h2><blockquote>
<p>tuple.go<br>At this point, your code should pass the unit tests in tuple_test.go.</p>
</blockquote>
<p>此时，您的代码应该通过 tuple_test.go 中的单元测试。 </p>
<h2 id="TupleDesc"><a href="#TupleDesc" class="headerlink" title="TupleDesc"></a>TupleDesc</h2><p>类型FileType</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FieldType is the type of a field in a tuple, e.g., its name, table, and [godb.DBType].</span></span><br><span class="line"><span class="comment">// TableQualifier may or may not be an emtpy string, depending on whether the table</span></span><br><span class="line"><span class="comment">// was specified in the query</span></span><br><span class="line"><span class="keyword">type</span> FieldType <span class="keyword">struct</span> &#123;</span><br><span class="line">    Fname          <span class="type">string</span></span><br><span class="line">    TableQualifier <span class="type">string</span></span><br><span class="line">    Ftype          DBType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型 TupleDesc</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TupleDesc is &quot;type&quot; of the tuple, e.g., the field names and types</span></span><br><span class="line"><span class="keyword">type</span> TupleDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">	Fields []FieldType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TupleDesc 由一个FieldType切片组成，描述Tuple中数据的名称，Table名与类型</p>
<h2 id="TupleDesc-equals-方法"><a href="#TupleDesc-equals-方法" class="headerlink" title="TupleDesc.equals 方法"></a>TupleDesc.equals 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compare two tuple descs, and return true iff</span></span><br><span class="line"><span class="comment">// all of their field objects are equal and they</span></span><br><span class="line"><span class="comment">// are the same length</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d1 *TupleDesc)</span></span> equals(d2 *TupleDesc) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 若 d1 和 d2 的长度不相等，则返回 false</span></span><br><span class="line">	length := <span class="built_in">len</span>(d1.Fields)</span><br><span class="line">	<span class="keyword">if</span> length != <span class="built_in">len</span>(d2.Fields) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 比较 d1 和 d2 的每一个字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">		f1 := d1.Fields[i]</span><br><span class="line">		f2 := d2.Fields[i]</span><br><span class="line">		<span class="comment">// 若 f1 和 f2 的字段名或字段类型或表名不相等，则返回 false</span></span><br><span class="line">		<span class="keyword">if</span> f1.Fname != f2.Fname || f1.Ftype != f2.Ftype || f1.TableQualifier != f2.TableQualifier &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较d1 和 d2 是否相同</p>
<h2 id="TupleDesc-copy-方法"><a href="#TupleDesc-copy-方法" class="headerlink" title="TupleDesc.copy 方法"></a>TupleDesc.copy 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make a copy of a tuple desc.  Note that in go, assignment of a slice to</span></span><br><span class="line"><span class="comment">// another slice object does not make a copy of the contents of the slice.</span></span><br><span class="line"><span class="comment">// Look at the built-in function &quot;copy&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(td *TupleDesc)</span></span> <span class="built_in">copy</span>() *TupleDesc &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 初始化一个FieldType类型的切片</span></span><br><span class="line">	fields := <span class="built_in">make</span>([]FieldType, <span class="built_in">len</span>(td.Fields))</span><br><span class="line">	<span class="comment">// 将 td.Fields 的内容复制到 fields 中</span></span><br><span class="line">	<span class="built_in">copy</span>(fields, td.Fields)</span><br><span class="line">	<span class="keyword">return</span> &amp;TupleDesc&#123;Fields: fields&#125; <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 td 拷贝一份并返回</p>
<h2 id="TupleDesc-merge-方法"><a href="#TupleDesc-merge-方法" class="headerlink" title="TupleDesc.merge 方法"></a>TupleDesc.merge 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge two TupleDescs together.  The resulting TupleDesc</span></span><br><span class="line"><span class="comment">// should consist of the fields of desc2</span></span><br><span class="line"><span class="comment">// appended onto the fields of desc.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(desc *TupleDesc)</span></span> merge(desc2 *TupleDesc) *TupleDesc &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 初始化一个FieldType类型的切片，长度为 desc.Fields 的长度加上 desc2.Fields 的长度</span></span><br><span class="line">	length1 := <span class="built_in">len</span>(desc.Fields)</span><br><span class="line">	length2 := <span class="built_in">len</span>(desc2.Fields)</span><br><span class="line">	fields := <span class="built_in">make</span>([]FieldType, length1, length1+length2)</span><br><span class="line">	<span class="comment">// 将 desc.Fields 的内容复制到 fields 中</span></span><br><span class="line">	<span class="built_in">copy</span>(fields, desc.Fields)</span><br><span class="line">	<span class="comment">// 将 desc2.Fields 的内容添加到 fields 中</span></span><br><span class="line">	fields = <span class="built_in">append</span>(fields, desc2.Fields...)</span><br><span class="line">	<span class="keyword">return</span> &amp;TupleDesc&#123;Fields: fields&#125; <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 desc2 接到 desc 后， 并返回一个新的TupleDesc</p>
<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface used for tuple field values</span></span><br><span class="line"><span class="comment">// Since it implements no methods, any object can be used</span></span><br><span class="line"><span class="comment">// but having an interface for this improves code readability</span></span><br><span class="line"><span class="comment">// where tuple values are used</span></span><br><span class="line"><span class="keyword">type</span> DBValue <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer field value</span></span><br><span class="line"><span class="keyword">type</span> IntField <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String field value</span></span><br><span class="line"><span class="keyword">type</span> StringField <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tuple represents the contents of a tuple read from a database</span></span><br><span class="line"><span class="comment">// It includes the tuple descriptor, and the value of the fields</span></span><br><span class="line"><span class="keyword">type</span> Tuple <span class="keyword">struct</span> &#123;</span><br><span class="line">	Desc   TupleDesc</span><br><span class="line">	Fields []DBValue</span><br><span class="line">	Rid    recordID <span class="comment">//used to track the page and position this page was read from</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> recordID <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tuple 由Desc描述，Fields 数据与recordID组成</p>
<h2 id="Tuple-writeTo方法"><a href="#Tuple-writeTo方法" class="headerlink" title="Tuple.writeTo方法"></a>Tuple.writeTo方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serialize the contents of the tuple into a byte array Since all tuples are of</span></span><br><span class="line"><span class="comment">// fixed size, this method should simply write the fields in sequential order</span></span><br><span class="line"><span class="comment">// into the supplied buffer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See the function [binary.Write].  Objects should be serialized in little</span></span><br><span class="line"><span class="comment">// endian oder.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Strings can be converted to byte arrays by casting to []byte. Note that all</span></span><br><span class="line"><span class="comment">// strings need to be padded to StringLength bytes (set in types.go). For</span></span><br><span class="line"><span class="comment">// example if StringLength is set to 5, the string &#x27;mit&#x27; should be written as</span></span><br><span class="line"><span class="comment">// &#x27;m&#x27;, &#x27;i&#x27;, &#x27;t&#x27;, 0, 0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May return an error if the buffer has insufficient capacity to store the</span></span><br><span class="line"><span class="comment">// tuple.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tuple)</span></span> writeTo(b *bytes.Buffer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 遍历 t.Fields，将每个字段的值写入 b 中</span></span><br><span class="line">	<span class="keyword">for</span> i, field := <span class="keyword">range</span> t.Fields &#123;</span><br><span class="line">		<span class="comment">// 判断数据类型</span></span><br><span class="line">		<span class="keyword">if</span> t.Desc.Fields[i].Ftype == IntType &#123;</span><br><span class="line">			<span class="comment">// 若为 IntType，则将 int64 直接写入</span></span><br><span class="line">			err := binary.Write(b, binary.LittleEndian, field.(IntField).Value)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Desc.Fields[i].Ftype == StringType &#123;</span><br><span class="line">			<span class="comment">// 初始化一个长度为 StringLength 的字节数组</span></span><br><span class="line">			data := <span class="built_in">make</span>([]<span class="type">byte</span>, StringLength)</span><br><span class="line">			<span class="comment">// 若为 StringType，则将 string 转换为字节数组</span></span><br><span class="line">			<span class="built_in">copy</span>(data, []<span class="type">byte</span>(field.(StringField).Value))</span><br><span class="line">			<span class="comment">// 将 data 写入 b 中</span></span><br><span class="line">			err := binary.Write(b, binary.LittleEndian, data)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> GoDBError&#123;</span><br><span class="line">				code:      <span class="number">0</span>,</span><br><span class="line">				errString: <span class="string">&quot;unkonwn type err&quot;</span>,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 Tuple中的字段序列化写入 buffer中<br>区分 IntType 和 StringType<br>int类型以int64进行写入<br>string类型补充StringLength长度后写入</p>
<blockquote>
<p>！不确定UnknownType 如何处理<br>暂时以报错进行处理</p>
</blockquote>
<h2 id="Tuple-readTupleFrom-方法"><a href="#Tuple-readTupleFrom-方法" class="headerlink" title="Tuple.readTupleFrom 方法"></a>Tuple.readTupleFrom 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> recordID inplement</span></span><br><span class="line"><span class="keyword">type</span> RecordID <span class="keyword">struct</span> &#123;</span><br><span class="line">	PageNo <span class="type">int</span></span><br><span class="line">	SlotNo <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read the contents of a tuple with the specified [TupleDesc] from the</span></span><br><span class="line"><span class="comment">// specified buffer, returning a Tuple.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See [binary.Read]. Objects should be deserialized in little endian oder.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All strings are stored as StringLength byte objects.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Strings with length &lt; StringLength will be padded with zeros, and these</span></span><br><span class="line"><span class="comment">// trailing zeros should be removed from the strings.  A []byte can be cast</span></span><br><span class="line"><span class="comment">// directly to string.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May return an error if the buffer has insufficent data to deserialize the</span></span><br><span class="line"><span class="comment">// tuple.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readTupleFrom</span><span class="params">(b *bytes.Buffer, desc *TupleDesc)</span></span> (*Tuple, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// fields 存储每个字段的值</span></span><br><span class="line">	fields := <span class="built_in">make</span>([]DBValue, <span class="built_in">len</span>(desc.Fields))</span><br><span class="line">	<span class="comment">// 遍历 desc.Fields，将每个字段的值存储到 fields 中</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> desc.Fields &#123;</span><br><span class="line">		<span class="comment">// 判断数据类型</span></span><br><span class="line">		<span class="keyword">if</span> v.Ftype == IntType &#123;</span><br><span class="line">			<span class="comment">// 若未 IntType，则读取 int64</span></span><br><span class="line">			<span class="keyword">var</span> field_value IntField</span><br><span class="line">			err := binary.Read(b, binary.LittleEndian, &amp;field_value.Value)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			fields[i] = field_value</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> v.Ftype == StringType &#123;</span><br><span class="line">			<span class="comment">// 若为 StringType，则读取 StringLength 长度的字节数组，再将字节数组转换为 string</span></span><br><span class="line">			<span class="keyword">var</span> field_value StringField</span><br><span class="line">			stringBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, StringLength)</span><br><span class="line">			err := binary.Read(b, binary.LittleEndian, &amp;stringBytes)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 去除字符串中的空字符</span></span><br><span class="line">			c := bytes.Trim(stringBytes, <span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">			field_value.Value = <span class="type">string</span>(c)</span><br><span class="line">			fields[i] = field_value</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 若为 UnknownType，则返回错误</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, GoDBError&#123;</span><br><span class="line">				code:      <span class="number">0</span>,</span><br><span class="line">				errString: <span class="string">&quot;unkonwn type err&quot;</span>,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个 Tuple 对象</span></span><br><span class="line">	<span class="keyword">return</span> &amp;Tuple&#123;</span><br><span class="line">		Desc:   *desc.<span class="built_in">copy</span>(),</span><br><span class="line">		Fields: fields,</span><br><span class="line">		Rid: RecordID&#123;</span><br><span class="line">			PageNo: <span class="number">-1</span>,</span><br><span class="line">			SlotNo: <span class="number">-1</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;, <span class="literal">nil</span> <span class="comment">//replace me</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从buffer中读取数据，根据desc中提供的类型<br>int类型以int64读入<br>string类型以stringlength长度字节串读入。<br>将data中的数据转换为fields</p>
<blockquote>
<p>！不确定UnknownType 如何处理<br>以报错处理</p>
</blockquote>
<h2 id="Tuple-equals-方法"><a href="#Tuple-equals-方法" class="headerlink" title="Tuple.equals 方法"></a>Tuple.equals 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compare two tuples for equality.  Equality means that the TupleDescs are equal</span></span><br><span class="line"><span class="comment">// and all of the fields are equal.  TupleDescs should be compared with</span></span><br><span class="line"><span class="comment">// the [TupleDesc.equals] method, but fields can be compared directly with equality</span></span><br><span class="line"><span class="comment">// operators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t1 *Tuple)</span></span> equals(t2 *Tuple) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 先判断 t1 和 t2 的 TupleDesc 是否相等</span></span><br><span class="line">	<span class="keyword">if</span> !t1.Desc.equals(&amp;t2.Desc) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 再判断 t1 和 t2 的 Fields 是否相等</span></span><br><span class="line">	<span class="comment">// 若长度不相等，则返回 false</span></span><br><span class="line">	length := <span class="built_in">len</span>(t1.Fields)</span><br><span class="line">	<span class="keyword">if</span> length != <span class="built_in">len</span>(t2.Fields) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历 t1 和 t2 的 Fields，比较每个字段的值</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> t1.Fields[i] != t2.Fields[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较 t1 和 t2 是否相等<br>TupleDesc 使用 TupleDesc.equals 方法<br>Fields 进行遍历比较</p>
<h2 id="Tuple-joinTuples-方法"><a href="#Tuple-joinTuples-方法" class="headerlink" title="Tuple.joinTuples 方法"></a>Tuple.joinTuples 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge two tuples together, producing a new tuple with the fields of t2 appended to t1.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joinTuples</span><span class="params">(t1 *Tuple, t2 *Tuple)</span></span> *Tuple &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 合并 t1 和 t2 的 TupleDesc</span></span><br><span class="line">	desc := t1.Desc.merge(&amp;t2.Desc)</span><br><span class="line">	<span class="comment">// 合并 t1 和 t2 的 Fields</span></span><br><span class="line">	fields := <span class="built_in">append</span>(t1.Fields, t2.Fields...)</span><br><span class="line">	<span class="keyword">return</span> &amp;Tuple&#123;</span><br><span class="line">		Desc:   *desc,</span><br><span class="line">		Fields: fields,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并 t1 和 t2<br>先合并 Desc，使用Desc.merge方法<br>再合并Fields</p>
<h2 id="Tuple-compareField-方法"><a href="#Tuple-compareField-方法" class="headerlink" title="Tuple.compareField 方法"></a>Tuple.compareField 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply the supplied expression to both t and t2, and compare the results,</span></span><br><span class="line"><span class="comment">// returning an orderByState value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Takes an arbitrary expressions rather than a field, because, e.g., for an</span></span><br><span class="line"><span class="comment">// ORDER BY SQL may ORDER BY arbitrary expressions, e.g., substr(name, 1, 2)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that in most cases Expr will be a [godb.FieldExpr], which simply</span></span><br><span class="line"><span class="comment">// extracts a named field from a supplied tuple.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Calling the [Expr.EvalExpr] method on a tuple will return the value of the</span></span><br><span class="line"><span class="comment">// expression on the supplied tuple.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tuple)</span></span> compareField(t2 *Tuple, field Expr) (orderByState, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 调用 Expr.EvalExpr 方法，获取 t 和 t2 中字段的值</span></span><br><span class="line">	val1, err := field.EvalExpr(t)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> OrderedEqual, err</span><br><span class="line">	&#125;</span><br><span class="line">	val2, err := field.EvalExpr(t2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> OrderedEqual, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断字段的类型</span></span><br><span class="line">	typeName := field.GetExprType().Ftype</span><br><span class="line">	<span class="keyword">if</span> typeName == IntType &#123;</span><br><span class="line">		<span class="comment">// 若为 IntType，则进行IntField类型的比较</span></span><br><span class="line">		value1 := val1.(IntField).Value</span><br><span class="line">		value2 := val2.(IntField).Value</span><br><span class="line">		<span class="keyword">if</span> value1 &lt; value2 &#123;</span><br><span class="line">			<span class="keyword">return</span> OrderedLessThan, <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value1 &gt; value2 &#123;</span><br><span class="line">			<span class="keyword">return</span> OrderedGreaterThan, <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> OrderedEqual, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> typeName == StringType &#123;</span><br><span class="line">		<span class="comment">// 若为 StringType，则进行StringField类型的比较</span></span><br><span class="line">		value1 := val1.(StringField).Value</span><br><span class="line">		value2 := val2.(StringField).Value</span><br><span class="line">		<span class="keyword">if</span> value1 &lt; value2 &#123;</span><br><span class="line">			<span class="keyword">return</span> OrderedLessThan, <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value1 &gt; value2 &#123;</span><br><span class="line">			<span class="keyword">return</span> OrderedGreaterThan, <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> OrderedEqual, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OrderedEqual, GoDBError&#123;</span><br><span class="line">		code:      <span class="number">0</span>,</span><br><span class="line">		errString: <span class="string">&quot;err&quot;</span>,</span><br><span class="line">	&#125; <span class="comment">// replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取t和t2的值<br>然后获取类型<br>根据类型进行类型断言处理，比较值的结果</p>
<h2 id="Tuple-project-方法"><a href="#Tuple-project-方法" class="headerlink" title="Tuple.project 方法"></a>Tuple.project 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Project out the supplied fields from the tuple. Should return a new Tuple</span></span><br><span class="line"><span class="comment">// with just the fields named in fields.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Should not require a match on TableQualifier, but should prefer fields that</span></span><br><span class="line"><span class="comment">// do match on TableQualifier (e.g., a field  t1.name in fields should match an</span></span><br><span class="line"><span class="comment">// entry t2.name in t, but only if there is not an entry t1.name in t)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tuple)</span></span> project(fields []FieldType) (*Tuple, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 初始化一个 DBValue 类型的切片</span></span><br><span class="line">	values := <span class="built_in">make</span>([]DBValue, <span class="built_in">len</span>(fields))</span><br><span class="line">	<span class="comment">// 依次获取 fields 中对应的字段的值</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> fields &#123;</span><br><span class="line">		ans := <span class="number">-1</span></span><br><span class="line">		<span class="comment">// 遍历 t.Desc.Fields，找到对应的字段</span></span><br><span class="line">		<span class="keyword">for</span> j, val := <span class="keyword">range</span> t.Desc.Fields &#123;</span><br><span class="line">			<span class="keyword">if</span> val.Fname == v.Fname &#123;</span><br><span class="line">				ans = j</span><br><span class="line">				<span class="comment">// 只有当 TableQualifier 相等时，为精准匹配</span></span><br><span class="line">				<span class="keyword">if</span> val.TableQualifier == v.TableQualifier &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若未找到对应的字段，则返回错误</span></span><br><span class="line">		<span class="keyword">if</span> ans == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, GoDBError&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将字段的值存储到 values 中</span></span><br><span class="line">		values[i] = t.Fields[ans]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Tuple&#123;</span><br><span class="line">		Fields: values,</span><br><span class="line">	&#125;, <span class="literal">nil</span> <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 tuples 投影出 fields中对应的字段<br>通过遍历进行寻找fields中对应的字段</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>tuple_test</code></p>
<img src="/2024/01/12/mit-6583-lab1E/1703147235363-f21f961f-4947-40ac-8cd3-d19e9d46ada2.png" class="" title="image.png">
<p>全部测试通过</p>
<h1 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h1><h2 id="Q"><a href="#Q" class="headerlink" title="Q:"></a>Q:</h2><blockquote>
<p>实现<code>getPage()</code> 方法<br><code>buffer_pool.go</code><br>There is a unit test buffer_pool_test.go, but you will not be able to pass this testuntil you implement the heap file and heap page methods below. You will also test the functionalityof the buffer pool when you implement your heap file iterator.<br>When more than this many pages are in the buffer pool, one page should be evicted from the pool before the next is loaded. The choice of eviction policy is up to you; it is not necessary to do something sophisticated.<br>Notice that BufferPool asks you to implementa flush_all_pages() method. This is not something you would everneed in a real implementation of a buffer pool. However, we need this methodfor testing purposes. You really should never call this method from anywherein your code.</p>
</blockquote>
<p>存在单元测试Buffer_Pool_Test.go，但在实现下面的堆文件和堆页面方法之前，您将无法通过此测试。在实现堆文件迭代器时，您还将测试缓冲池的功能。<br>当缓冲池中的页面数量超过这个数目时，应该在加载下一个页面之前将一个页面从池中逐出。驱逐政策的选择由你自己决定；没有必要做一些复杂的事情。<br>注意，BufferPool要求您实现flush_all_ages()方法。在真正的缓冲池实现中，这不是您永远需要的东西。<br>然而，出于测试目的，我们需要此方法。您真的不应该从代码中的任何位置调用此方法。</p>
<h2 id="Bufferpool"><a href="#Bufferpool" class="headerlink" title="Bufferpool"></a>Bufferpool</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BufferPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	pages    <span class="keyword">map</span>[<span class="type">uint64</span>]*Page <span class="comment">// 用于存储页面, key为pageKey(FileName, PageNo)</span></span><br><span class="line">	numPages <span class="type">int</span>              <span class="comment">// BufferPool的容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new BufferPool with the specified number of pages</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBufferPool</span><span class="params">(numPages <span class="type">int</span>)</span></span> *BufferPool &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	pages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]*Page, numPages)</span><br><span class="line">	<span class="keyword">return</span> &amp;BufferPool&#123;pages: pages, numPages: numPages&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BufferPool中含有一个map存储Page, numPages为BufferPool的容量<br>在HeapFile中实现的PageKey方法，为对应的FileName和PageNo生成一个哈希值作为key</p>
<h2 id="Bufferpool-FlushAllPages"><a href="#Bufferpool-FlushAllPages" class="headerlink" title="Bufferpool.FlushAllPages()"></a>Bufferpool.FlushAllPages()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Testing method -- iterate through all pages in the buffer pool</span></span><br><span class="line"><span class="comment">// and flush them using [DBFile.flushPage]. Does not need to be thread/transaction safe</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bp *BufferPool)</span></span> FlushAllPages() &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 遍历所有页面，将页面写入磁盘</span></span><br><span class="line">	<span class="keyword">for</span> _, page := <span class="keyword">range</span> bp.pages &#123;</span><br><span class="line">		<span class="comment">// 如果页面不是空的，就写入磁盘</span></span><br><span class="line">		<span class="keyword">if</span> page != <span class="literal">nil</span> &#123;</span><br><span class="line">			file := (*page).getFile()</span><br><span class="line">			(*file).flushPage(page)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历所有的Page，调用dbfile的flush方法<br>测试方法，仅用于测试，在实际使用中不需要</p>
<h2 id="Bufferpool-GetPage"><a href="#Bufferpool-GetPage" class="headerlink" title="Bufferpool.GetPage()"></a>Bufferpool.GetPage()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bp *BufferPool)</span></span> GetPage(file DBFile, pageNo <span class="type">int</span>, tid TransactionID, perm RWPerm) (*Page, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	hpfile := file.(*HeapFile)</span><br><span class="line">	key := hpfile.pageKey(pageNo).(<span class="type">uint64</span>)</span><br><span class="line">	<span class="keyword">if</span> bp.pages[key] != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bp.pages[key], <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 判断buffer pool是否已满</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(bp.pages) &gt;= bp.numPages &#123;</span><br><span class="line">			<span class="comment">// 若已满，遍历所有页面，找到一个不是脏的页面，驱逐</span></span><br><span class="line">			flag := <span class="literal">false</span></span><br><span class="line">			<span class="keyword">for</span> _, page := <span class="keyword">range</span> bp.pages &#123;</span><br><span class="line">				<span class="comment">// 如果页面不是脏的，就可以驱逐</span></span><br><span class="line">				<span class="keyword">if</span> page != <span class="literal">nil</span> &amp;&amp; !(*page).isDirty() &#123;</span><br><span class="line">					hpfile.flushPage(page)</span><br><span class="line">					<span class="built_in">delete</span>(bp.pages, hpfile.pageKey(pageNo).(<span class="type">uint64</span>))</span><br><span class="line">					flag = <span class="literal">true</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果所有页面都是脏的，就报错</span></span><br><span class="line">			<span class="keyword">if</span> !flag &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, GoDBError&#123;</span><br><span class="line">					code:      PageFullError,</span><br><span class="line">					errString: <span class="string">&quot;buffer pool is full&quot;</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 读取页面</span></span><br><span class="line">		page, err := hpfile.readPage(pageNo)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		bp.pages[key] = page</span><br><span class="line">		<span class="keyword">return</span> page, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从BufferPool中获取pageNo对应的页面<br>根据Page的hash值，判断Page是否位于BufferPool中<br>若在，则直接返回<br>若不在，则从读取页面，存入BufferPool中<br>若BufferPool已满，则需要驱逐一个非脏页。</p>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p><code>buffer_pool_test.go</code><br>测试需要完成以下的HeapFile和HeapPage才能通过</p>
<h1 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h1><h2 id="Q-1"><a href="#Q-1" class="headerlink" title="Q:"></a>Q:</h2><blockquote>
<p><code>heap_page.go</code><br>Although you are not required to use exactly our interface for heap_page.go, you will likely find the methods we have provided to be useful and we recommend following our skeleton.</p>
</blockquote>
<p>尽管您不需要完全使用我们的heap_page.go接口，但您可能会发现我们提供的方法很有用，我们建议您遵循我们的框架。</p>
<blockquote>
<p>Assuming you follow our outline, there are five non-trivial methods to implement:</p>
<ol>
<li>insertTuple() : This method should add a tuple to the page if there is space. Because a heap file is unordered, itcan be inserted in any free slot.</li>
<li>deleteTuple() : Delete a specific tuple from the page.Note that this method takes a specific recordID (or “rid”) to delete. recordID is an empty interface; you are freeto use any struct you like for the rid, but for a heap file a rid would typically include the page number and the slot number on the page.The page number would typically be the offset in the heap file of the page, and the slot number would likely by the position of the tuplein the in-memory slice of tuples on the page. You will set the rid field of the tuples you return from your iterator. Your heap file implementation should use this rid to identify the specific page to delete from, and then pass the rid into this method so that you can delete the appropriate tuple. Note that if you choose to represent a page in memory as a slice of tuples, and the slot in the rid is the position in the slice, you should take care to not cause the rid to change when you perform the deletion. One way to achieve this is to set the position in the slice to nil (rather than creating a new slice with the deleted tuple removed from it), but many implementations are possible.</li>
<li>toBuffer() : Serialize the pages to a bytes.Buffer object for saving to disk, using the binary.Write() method to encode the header and the writeTo() method from your tuple implementation. Note that the header includes the number of used slots, but does not encode which slots are empty and which are not. This is ok, because, in GoDB you do not need to preserve the record ids of records when they are written out (so a particular tuple’s rid may change after it is written and then read back.) </li>
<li>initFromBuffer() : Read the page from the specified buffer by reading the header with the binary.Read() method and then the tuples using the readTupleFrom() method.</li>
<li>tupleIter() : Return a function that can be invoked to interate through the tuples of the page. See the note about iterators in <a target="_blank" rel="noopener" href="https://www.yuque.com/icathianrain/pdya3s/kxbledbm2h46qbig#22-operators-and-iterators">2.2</a> above.</li>
</ol>
</blockquote>
<p>假设您遵循我们的大纲，有五种重要的方法可以实现：</p>
<ol>
<li><code>insertTuple()</code> ：如果有空间，此方法应该向页面添加一个元组。 由于堆文件是无序的，因此可以将其插入到任何空闲槽中。</li>
<li><code>deleteTuple()</code> ：从页面中删除特定的元组。请注意，此方法需要特定的 recordID（或“rid”）来删除。  recordID是一个空接口； 您可以自由地使用任何您喜欢的结构来删除，但对于堆文件，删除通常包括页码和页面上的槽号。页号通常是该页的堆文件中的偏移量，而槽号可能是该页上元组的内存片中元组的位置。 您将设置从迭代器返回的元组的 Rid 字段。 您的堆文件实现应该使用此rid 来识别要从中删除的特定页面，然后将rid 传递到此方法中，以便您可以删除适当的元组。 请注意，如果您选择将内存中的页面表示为元组切片，并且rid中的槽是切片中的位置，则应注意在执行删除时不要导致rid发生更改。 实现此目的的一种方法是将切片中的位置设置为 nil（而不是创建一个新切片并从中删除已删除的元组），但许多实现都是可能的。</li>
<li><code>toBuffer()</code> ：将页面序列化为 <code>bytes.Buffer</code> 对象以保存到磁盘，使用 <code>binary.Write()</code> 方法对标头进行编码，并使用元组实现中的 <code>writeTo()</code> 方法 。 请注意，标头包括已使用的时隙数，但不编码哪些时隙为空、哪些时隙不是。 这是可以的，因为在 GoDB 中，您不需要在写出记录时保留记录的记录 ID（因此特定元组的 ID 在写入然后读回后可能会发生变化。）</li>
<li><code>initFromBuffer()</code> ： 通过使用“binary.Read()”方法读取标头，然后使用“readTupleFrom()”方法读取元组，从指定缓冲区读取页面。</li>
<li><code>tupleIter()</code> ：返回一个可以被调用以通过页面的元组进行交互的函数。 请参阅上面 <a href="#22-operators-and-iterators">2.2</a> 中有关迭代器的注释。<blockquote>
<p>There are a few other methods (setDirty(), isDirty(), getNumSlots(), and the newHeapPage() constructor) that you will need to implement, but these should be straightfoward.<br>At this point, your code should pass the unit tests in heap_page_test.go.<br>After you have implemented HeapPage, you will write methods for HeapFile thatread pages from the file, iterate through pages, and insert and deleterecords.</p>
</blockquote>
</li>
</ol>
<p>您还需要实现一些其他方法（<code>setDirty()</code>、<code>isDirty()</code>、<code>getNumSlots()</code> 和 <code>newHeapPage()</code> 构造函数），但这些方法应该很简单。<br>此时，您的代码应该通过“heap_page_test.go”中的单元测试。<br>实现“HeapPage”后，您将为“HeapFile”编写方法 从文件中读取页面、遍历页面以及插入和删除记录。</p>
<h2 id="heapPage"><a href="#heapPage" class="headerlink" title="heapPage"></a>heapPage</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> heapPage <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	pageNo   <span class="type">int</span>        <span class="comment">// 页号</span></span><br><span class="line">	tuples   []*Tuple   <span class="comment">// 页面上的元组, 若为nil代表空闲</span></span><br><span class="line">	td       *TupleDesc <span class="comment">// 元组描述</span></span><br><span class="line">	numSlots <span class="type">int32</span>      <span class="comment">// 页面上的总槽位数</span></span><br><span class="line">	numUsed  <span class="type">int32</span>      <span class="comment">// 页面上已经使用的槽位数</span></span><br><span class="line">	dirty    <span class="type">bool</span>       <span class="comment">// 是否脏页</span></span><br><span class="line">	file     DBFile     <span class="comment">// page对应的DBFile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construct a new heap page</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHeapPage</span><span class="params">(desc *TupleDesc, pageNo <span class="type">int</span>, f *HeapFile)</span></span> *heapPage &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	size := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 计算单个元组大小</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> desc.Fields &#123;</span><br><span class="line">		<span class="keyword">switch</span> v.Ftype &#123;</span><br><span class="line">		<span class="keyword">case</span> IntType:</span><br><span class="line">			<span class="comment">// 若为int64, 则size为8</span></span><br><span class="line">			size += <span class="type">int</span>(unsafe.Sizeof(<span class="type">int64</span>(<span class="number">0</span>)))</span><br><span class="line">		<span class="keyword">case</span> StringType:</span><br><span class="line">			<span class="comment">// 若为字符串，则为StringLength大小</span></span><br><span class="line">			size += StringLength * <span class="type">int</span>(unsafe.Sizeof(<span class="type">byte</span>(<span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算槽位数</span></span><br><span class="line">	numSlots := <span class="type">int32</span>((PageSize - <span class="number">8</span>) / size)</span><br><span class="line">	<span class="keyword">return</span> &amp;heapPage&#123;</span><br><span class="line">		pageNo:   pageNo,</span><br><span class="line">		tuples:   <span class="built_in">make</span>([]*Tuple, numSlots),</span><br><span class="line">		td:       desc,</span><br><span class="line">		numSlots: numSlots,</span><br><span class="line">		numUsed:  <span class="number">0</span>,</span><br><span class="line">		dirty:    <span class="literal">false</span>,</span><br><span class="line">		file:     f,</span><br><span class="line">	&#125; <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个页面在文件中的存储如下</p>
<ul>
<li>大小为PageSize</li>
<li>4个字节存储numSlots</li>
<li>4个字节存储numUsed</li>
<li>剩下存储numSlots个槽的内容<br>:::info<br>!Attention:<br>若页面不能刚好存储整数倍个槽的时候或有空闲的槽，存在空位需要用0来填充（否则影响下一个页面）<br>将页面内容写入文件时，空的槽不写入，存数据的槽直接写入<br>下次读取页面的时候，数据将填充前numUsed个槽<br>简单理解: 0, 2, 4, 5, 6, 10槽有数据，写入文件，则文件前6个槽中有数据<br>下次读取时，RecordID变为0,1,2,3,4,5<br>:::</li>
</ul>
<h2 id="NumSlots"><a href="#NumSlots" class="headerlink" title="NumSlots"></a>NumSlots</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heapPage)</span></span> getNumSlots() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(h.numSlots) <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heapPage)</span></span> getNumEmptySlots() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(h.numSlots - h.numUsed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回现有的槽数，空闲的槽数</p>
<h2 id="insertTuple"><a href="#insertTuple" class="headerlink" title="insertTuple"></a>insertTuple</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert the tuple into a free slot on the page, or return an error if there are</span></span><br><span class="line"><span class="comment">// no free slots.  Set the tuples rid and return it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heapPage)</span></span> insertTuple(t *Tuple) (recordID, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 判断是否为符合的元组</span></span><br><span class="line">	<span class="keyword">if</span> h.td.equals(&amp;t.Desc) &#123;</span><br><span class="line">		<span class="comment">// 判断是否有空位</span></span><br><span class="line">		<span class="keyword">if</span> h.numUsed &lt; h.numSlots &#123;</span><br><span class="line">			<span class="comment">// 寻找空位</span></span><br><span class="line">			<span class="keyword">for</span> i, v := <span class="keyword">range</span> h.tuples &#123;</span><br><span class="line">				<span class="comment">// 若为空，则插入</span></span><br><span class="line">				<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">					t.Rid = RecordID&#123;</span><br><span class="line">						PageNo: h.pageNo,</span><br><span class="line">						SlotNo: i,</span><br><span class="line">					&#125;</span><br><span class="line">					h.tuples[i] = t</span><br><span class="line">					h.numUsed++</span><br><span class="line">					<span class="keyword">return</span> t.Rid, <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 若没有空位， 返回错误</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, GoDBError&#123;code: PageFullError, errString: <span class="string">&quot;no free slots&quot;</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若没有空位，返回错误</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, GoDBError&#123;code: PageFullError, errString: <span class="string">&quot;no free slots&quot;</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若类型不符合，返回错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, GoDBError&#123;code: TypeMismatchError, errString: <span class="string">&quot;tuple&#x27;s desc doesn&#x27;t match&quot;</span>&#125; <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在heapPage中，可以通过遍历tuples数组，若值为nil则说明为空，插入Tuple</p>
<h2 id="deleteTuple"><a href="#deleteTuple" class="headerlink" title="deleteTuple"></a>deleteTuple</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete the tuple in the specified slot number, or return an error if</span></span><br><span class="line"><span class="comment">// the slot is invalid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heapPage)</span></span> deleteTuple(rid recordID) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 获取槽位号</span></span><br><span class="line">	SlotNo := rid.(RecordID).SlotNo</span><br><span class="line">	<span class="comment">// 判断槽位号是否合法</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">int32</span>(SlotNo) &lt; h.numSlots &#123;</span><br><span class="line">		<span class="keyword">if</span> h.tuples[SlotNo] != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.tuples[SlotNo] = <span class="literal">nil</span></span><br><span class="line">			h.numUsed--</span><br><span class="line">            h.dirty = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> GoDBError&#123;code: TupleNotFoundError, errString: <span class="string">&quot;tuple not found&quot;</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> GoDBError&#123;code: TupleNotFoundError, errString: <span class="string">&quot;tuple Numer over&quot;</span>&#125; <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除指定recordID的元组</p>
<h2 id="Dirty-File"><a href="#Dirty-File" class="headerlink" title="Dirty &amp; File"></a>Dirty &amp; File</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Page method - return whether or not the page is dirty</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heapPage)</span></span> isDirty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="keyword">return</span> h.dirty <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Page method - mark the page as dirty</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heapPage)</span></span> setDirty(dirty <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	h.dirty = dirty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Page method - return the corresponding HeapFile</span></span><br><span class="line"><span class="comment">// for this page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *heapPage)</span></span> getFile() *DBFile &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="keyword">return</span> &amp;p.file <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="toBuffer"><a href="#toBuffer" class="headerlink" title="toBuffer()"></a>toBuffer()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heapPage)</span></span> toBuffer() (*bytes.Buffer, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	<span class="comment">// 写入页头</span></span><br><span class="line">	<span class="comment">// 写入槽位数</span></span><br><span class="line">	err := binary.Write(buf, binary.LittleEndian, h.numSlots)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入已使用的槽位数</span></span><br><span class="line">	err = binary.Write(buf, binary.LittleEndian, h.numUsed)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入元组</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> h.tuples &#123;</span><br><span class="line">		<span class="comment">// 若不为空，则写入</span></span><br><span class="line">		<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = v.writeTo(buf)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若还有空间，则填充</span></span><br><span class="line">	paddingLen := PageSize - buf.Len()</span><br><span class="line">	paddingBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, paddingLen)</span><br><span class="line">	_, err = buf.Write(paddingBytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf, <span class="literal">nil</span> <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先写入槽位数和已使用槽位数<br>接着将非空的写入<br>将剩余空间以0进行填充<br>读写前后，元组的RID会发生变化</p>
<h2 id="initFromBuffer"><a href="#initFromBuffer" class="headerlink" title="initFromBuffer"></a>initFromBuffer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read the contents of the HeapPage from the supplied buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heapPage)</span></span> initFromBuffer(buf *bytes.Buffer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 读取页头</span></span><br><span class="line">	<span class="comment">// 读取槽位数</span></span><br><span class="line">	binary.Read(buf, binary.LittleEndian, &amp;h.numSlots)</span><br><span class="line">	<span class="comment">// 读取已使用的槽位数</span></span><br><span class="line">	binary.Read(buf, binary.LittleEndian, &amp;h.numUsed)</span><br><span class="line">	<span class="comment">// 读取元组</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(h.numUsed); i++ &#123;</span><br><span class="line">		<span class="comment">// 读取元组</span></span><br><span class="line">		t, err := readTupleFrom(buf, h.td)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 写入tuples</span></span><br><span class="line">		h.tuples[i] = t</span><br><span class="line">		<span class="comment">// 更新tuples的Rid</span></span><br><span class="line">		h.tuples[i].Rid = RecordID&#123;</span><br><span class="line">			PageNo: h.pageNo,</span><br><span class="line">			SlotNo: i,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从字节数据中初始化页面<br>首先初始化页头<br>然后将存有数据的元组读取出来</p>
<h2 id="tupleIter"><a href="#tupleIter" class="headerlink" title="tupleIter"></a>tupleIter</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *heapPage)</span></span> tupleIter() <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*Tuple, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// index作为迭代</span></span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*Tuple, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="comment">// 若index小于槽位数且tuples[index]为空，则index++</span></span><br><span class="line">		<span class="comment">// 直到index大于槽位数或tuples[index]不为空</span></span><br><span class="line">		<span class="keyword">for</span> index &lt; <span class="type">int</span>(p.numSlots) &amp;&amp; p.tuples[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若index小于槽位数，则返回tuples[index]</span></span><br><span class="line">		<span class="keyword">if</span> index &lt; <span class="type">int</span>(p.numSlots) &#123;</span><br><span class="line">			index++</span><br><span class="line">			<span class="keyword">return</span> p.tuples[index], <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个迭代器函数函数<br>每调用一次该函数，将会返回下一个非空tuple，若为结尾则返回空</p>
<h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><p><code>heap_page_test.go</code></p>
<img src="/2024/01/12/mit-6583-lab1E/1703586128151-c7fa35e5-6edc-4c3e-a6fb-5250257c5ef9.png" class="" title="image.png">
<p>全部测试通过</p>
<h1 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h1><h2 id="Q：-1"><a href="#Q：-1" class="headerlink" title="Q："></a>Q：</h2><blockquote>
<p>Implement the skeleton methods in:<br><code>heap_file.go</code><br>There are a number of methods you need to implement; we have provided additional implementation tips in the comments in <code>heap_file.go</code>.</p>
<ol>
<li><code>NewHeapFile()</code> - The constructor.  It takes a file name that contains the binary encoding of the file (we name these <code>table.dat</code> by convention), as well as the TupleDesc that can be used to determine the expected format of the file and a buffer pool object that you will use to retrieve cached pages.</li>
<li><code>NumPages()</code> - Return the number of pages in the heap file;  you can use the <code>File.Stat()</code> method to determine the size of the heap file in bytes.</li>
<li><code>readPage()</code> - Read a specific page from storage. To read a page from disk, you will first need to calculate the correct offset in<br>the file. Hint: you will need random access to the file in order to read and<br>write pages at arbitrary offsets – check out the golang <code>os.File</code> type and its <code>ReadAt()</code> method.<br>You should not call <code>BufferPool</code> methods when reading a page from disk in the <code>readPage()</code> method, but you will<br>use the buffer pool <code>getPage()</code> method in your implementations of the heap file <code>iterator</code>.  Once you have read in the bytes of the page you can create the page using the heap page method <code>newHeapPage()</code>.  You can convert bytes read from a file to a buffer via the <code>bytes.NewBuffer()</code> method.</li>
<li><code>flushPage()</code> - Force a given page object back to disk.  The supplied page will be a <code>HeapPage</code>;  you should cast it and retrieve its bytes via the heap page method <code>toBytes()</code>.  You can then write these bytes back to the appropriate location on disk by opening the backing file and using a method like <code>os.File.WriteAt()</code>.</li>
<li><code>insertTuple()</code> - Add a tuple to the heap file;  because the heap file is unordered, it can be inserted in any free slot in the file</li>
<li><code>deleteTuple()</code> - Remove a specific tuple from the heap file.  You should use the rid field of the tuple to determine which page the<br>tuple is in, and call the heap page method <code>deleteTuple()</code> on the appropriage page.</li>
<li><code>Descriptor()</code></li>
<li><code>Iterator()</code> - Return a function that iterates through the tuples of the heap file one at a time.  You should iterate through the pages and use the <code>tupleIter()</code> to iterate through the the tuples of each heap page.  See the note above about iterators in GoDB in <a target="_blank" rel="noopener" href="https://www.yuque.com/icathianrain/pdya3s/kxbledbm2h46qbig#22-operators-and-iterators">2.2</a> above.<br>This method should read pages using the buffer pool method <code>getPage()</code> which will eventually be used (in<br>a later lab) to implement locking-based concurrency control and recovery. Do<br>not load the entire table into memory when the iterator is instantiated – this will cause an<br>out of memory error for very large tables.  Instead, you will just load one page at a<br>time as the buffer pool accesses them via calls to <code>readPage()</code>.</li>
<li><code>pageKey()</code> - Return a struct that can be used as a key for the page.  The buffer pool uses this to determine whether the page is cached or not.  We have provided an implementation hint in the comment of this function.</li>
</ol>
</blockquote>
<p>At this point, your code should pass the unit tests in <code>heap_file_test.go</code> and <code>buffer_pool_test.go</code>.  This completes the tests for this lab.  You should complete the final exercises in the next section.</p>
<p>您需要实施多种方法； 我们在 heap_file.go 的注释中提供了额外的实现技巧。</p>
<ol>
<li>NewHeapFile() - 构造函数。 它需要一个文件名，其中包含文件的二进制编码（我们按照惯例将这些文件命名为 table.dat），以及可用于确定文件的预期格式和您将使用的缓冲池对象的 TupleDesc 检索缓存的页面。</li>
<li>NumPages()——返回堆文件中的页数； 您可以使用 File.Stat() 方法来确定堆文件的大小（以字节为单位）。</li>
<li>readPage() - 从存储中读取特定页面。 要从磁盘读取页面，您首先需要计算正确的偏移量文件。 提示：您需要随机访问该文件才能读取和 以任意偏移量写入页面——查看 golang os.File 类型及其 ReadAt() 方法。在 readPage() 方法中从磁盘读取页面时，不应调用 BufferPool 方法，但您会 在堆文件迭代器的实现中使用缓冲池 getPage() 方法。 读入页面的字节后，您可以使用堆页面方法 newHeapPage() 创建页面。 您可以通过 bytes.NewBuffer() 方法将从文件读取的字节转换为缓冲区。</li>
<li>flushPage() - 强制给定的页面对象返回磁盘。 提供的页面将是HeapPage； 您应该通过堆页方法 toBytes() 对其进行强制转换并检索其字节。 然后，您可以通过打开备份文件并使用 os.File.WriteAt() 等方法将这些字节写回磁盘上的适当位置。</li>
<li>insertTuple() - 将元组添加到堆文件中； 由于堆文件是无序的，因此可以将其插入到文件中的任何空闲槽中</li>
<li>deleteTuple() - 从堆文件中删除特定的元组。 您应该使用元组的rid字段来确定哪个页面 tuple进入，并在相应的页上调用堆页方法deleteTuple()。</li>
<li>Descriptor()</li>
<li>Iterator() - 返回一个一次迭代堆文件元组的函数。 您应该迭代页面并使用 tupleIter() 迭代每个堆页面的元组。 请参阅上面 2.2 中关于 GoDB 迭代器的注释。此方法应使用最终将使用的缓冲池方法 getPage() 读取页面（在 稍后的实验）来实现基于锁定的并发控制和恢复。 做 当迭代器实例化时，不要将整个表加载到内存中——这将导致 非常大的表出现内存不足错误。 相反，您只需加载一页 缓冲池通过调用 readPage() 访问它们的时间。</li>
<li>pageKey() - 返回一个可以用作页面键的结构。 缓冲池使用它来确定页面是否被缓存。 我们在该函数的注释中提供了实现提示。</li>
</ol>
<p>此时，您的代码应该通过 heap_file_test.go 和 buffer_pool_test.go 中的单元测试。 本实验室的测试就此完成。 您应该完成下一节中的最终练习。</p>
<h2 id="HeapFile"><a href="#HeapFile" class="headerlink" title="HeapFile"></a>HeapFile</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HeapFile <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// HeapFile should include the fields below;  you may want to add</span></span><br><span class="line">	<span class="comment">// additional fields</span></span><br><span class="line">	bufPool    *BufferPool <span class="comment">// buffer pool</span></span><br><span class="line">	sync.Mutex             <span class="comment">// mutex</span></span><br><span class="line">	fromFile   <span class="type">string</span>      <span class="comment">// file name</span></span><br><span class="line">	td         *TupleDesc  <span class="comment">// tuple descriptor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHeapFile</span><span class="params">(fromFile <span class="type">string</span>, td *TupleDesc, bp *BufferPool)</span></span> (*HeapFile, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 创建或打开文件</span></span><br><span class="line">	file, err := os.OpenFile(fromFile, os.O_RDWR|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="keyword">return</span> &amp;HeapFile&#123;</span><br><span class="line">		fromFile: fromFile,</span><br><span class="line">		td:       td,</span><br><span class="line">		bufPool:  bp,</span><br><span class="line">	&#125;, <span class="literal">nil</span> <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fromFile文件名<br>td tuple描述</p>
<h2 id="NumPages"><a href="#NumPages" class="headerlink" title="NumPages"></a>NumPages</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the number of pages in the heap file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *HeapFile)</span></span> NumPages() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 获取文件大小</span></span><br><span class="line">	FileInfo, err := os.Stat(f.fromFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	fileSize := FileInfo.Size()</span><br><span class="line">	<span class="comment">// 计算页数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(fileSize) / PageSize <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的页面数是根据数据库文件的大小确定的</p>
<h2 id="readPage"><a href="#readPage" class="headerlink" title="readPage"></a>readPage</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *HeapFile)</span></span> readPage(pageNo <span class="type">int</span>) (*Page, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	file, _ := os.Open(f.fromFile)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, PageSize)</span><br><span class="line">	<span class="comment">// 计算偏移量</span></span><br><span class="line">	offset := PageSize * pageNo</span><br><span class="line">	<span class="comment">// 读取文件</span></span><br><span class="line">	_, err := file.ReadAt(buf, <span class="type">int64</span>(offset))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据数据库内容初始化page</span></span><br><span class="line">	hp := newHeapPage(f.td, pageNo, f)</span><br><span class="line">	err = hp.initFromBuffer(bytes.NewBuffer(buf))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> page Page = hp</span><br><span class="line">	<span class="comment">// 返回page</span></span><br><span class="line">	<span class="keyword">return</span> &amp;page, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从文件中对应位置读取内容<br>然后初始化页面</p>
<h2 id="flushPage"><a href="#flushPage" class="headerlink" title="flushPage"></a>flushPage</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *HeapFile)</span></span> flushPage(p *Page) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	file, _ := os.OpenFile(f.fromFile, os.O_RDWR|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	pageNo := (*p).(*heapPage).pageNo</span><br><span class="line">	<span class="comment">// 计算偏移量</span></span><br><span class="line">	offset := pageNo * PageSize</span><br><span class="line">	<span class="comment">// 将page转换为buffer</span></span><br><span class="line">	buf, err := (*p).(*heapPage).toBuffer()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入文件</span></span><br><span class="line">	number_bytes, err := file.WriteAt(buf.Bytes(), <span class="type">int64</span>(offset))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	_ = number_bytes</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将页面写入文件中对应位置</p>
<h2 id="insert-delete-Tuple"><a href="#insert-delete-Tuple" class="headerlink" title="insert &amp; delete Tuple"></a>insert &amp; delete Tuple</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *HeapFile)</span></span> insertTuple(t *Tuple, tid TransactionID) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 从现有的page中寻找空slot</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; f.NumPages(); i++ &#123;</span><br><span class="line">		<span class="comment">// 获取page</span></span><br><span class="line">		page, err := f.bufPool.GetPage(f, i, tid, ReadPerm)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		hp := (*page).(*heapPage)</span><br><span class="line">		<span class="comment">// 如果有空slot，插入tuple</span></span><br><span class="line">		<span class="keyword">if</span> hp.getNumEmptySlots() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 插入tuple</span></span><br><span class="line">			_, err := (*page).(*heapPage).insertTuple(t)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// no empty slots found, create new page</span></span><br><span class="line">	hp := newHeapPage(f.td, f.NumPages(), f)</span><br><span class="line">	<span class="comment">// add tuple to new page</span></span><br><span class="line">	_, err := hp.insertTuple(t)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write page to end of file</span></span><br><span class="line">	<span class="keyword">var</span> page Page = hp</span><br><span class="line">	<span class="comment">// 刷新page</span></span><br><span class="line">	f.flushPage(&amp;page)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看现有的page中是否有空的slot<br>使用bufPool读取page<br>如果有，则插入tuple<br>否则，新建一个页面，插入tuple，并将页面插入到文件的最后(flush page)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *HeapFile)</span></span> deleteTuple(t *Tuple, tid TransactionID) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 获取page</span></span><br><span class="line">	pageID := t.Rid.(RecordID).PageNo</span><br><span class="line">	page, err := f.bufPool.GetPage(f, <span class="type">int</span>(pageID), tid, ReadPerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 删除tuple</span></span><br><span class="line">	err = (*page).(*heapPage).deleteTuple(t.Rid)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据Tuple的RID获取page<br>再将RID传给page的删除tuple方法进行tuple删除</p>
<h2 id="Descriptor"><a href="#Descriptor" class="headerlink" title="Descriptor"></a>Descriptor</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *HeapFile)</span></span> Descriptor() *TupleDesc &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="keyword">return</span> f.td <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *HeapFile)</span></span> Iterator(tid TransactionID) (<span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*Tuple, <span class="type">error</span>), <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 迭代page</span></span><br><span class="line">    pageNo := <span class="number">0</span></span><br><span class="line">    <span class="comment">// page迭代tuple</span></span><br><span class="line">    <span class="keyword">var</span> iter <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*Tuple, <span class="type">error</span>) = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*Tuple, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历page</span></span><br><span class="line">        <span class="keyword">for</span> pageNo &lt; f.NumPages() &#123;</span><br><span class="line">            <span class="comment">// 获取page</span></span><br><span class="line">            page, err := f.bufPool.GetPage(f, pageNo, tid, ReadPerm)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            hp := (*page).(*heapPage)</span><br><span class="line">            <span class="comment">// 获取page的迭代器</span></span><br><span class="line">            <span class="keyword">if</span> iter == <span class="literal">nil</span> &#123;</span><br><span class="line">                iter = hp.tupleIter()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="comment">// 获取tuple</span></span><br><span class="line">                t, err := iter()</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// 若tuple为空，则pageNo++, iter置空</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上一个页面迭代完毕</span></span><br><span class="line">            pageNo++</span><br><span class="line">            iter = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pageNo负责迭代页面<br>iter负责页面内的元组迭代<br>注意迭代页面时将pageNo递增同时将iter置为nil，方便下个页面iter的获取</p>
<h2 id="heapHash"><a href="#heapHash" class="headerlink" title="heapHash"></a>heapHash</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// internal strucuture to use as key for a heap page</span></span><br><span class="line"><span class="keyword">type</span> heapHash <span class="keyword">struct</span> &#123;</span><br><span class="line">	FileName <span class="type">string</span></span><br><span class="line">	PageNo   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h heapHash)</span></span> Hash() [<span class="number">16</span>]<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">// md5 hash of filename + page number</span></span><br><span class="line">	<span class="keyword">return</span> md5.Sum([]<span class="type">byte</span>(h.FileName + strconv.Itoa(h.PageNo)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method returns a key for a page to use in a map object, used by</span></span><br><span class="line"><span class="comment">// BufferPool to determine if a page is cached or not.  We recommend using a</span></span><br><span class="line"><span class="comment">// heapHash struct as the key for a page, although you can use any struct that</span></span><br><span class="line"><span class="comment">// does not contain a slice or a map that uniquely identifies the page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *HeapFile)</span></span> pageKey(pgNo <span class="type">int</span>) any &#123;</span><br><span class="line">	HeapHash := heapHash&#123;</span><br><span class="line">		FileName: f.fromFile,</span><br><span class="line">		PageNo:   pgNo,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> HeapHash.Hash() <span class="comment">//replace me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将传入的pgNo与文件名进行hash</p>
<h2 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h2><p><code>heap_file_test.go</code></p>
<img src="/2024/01/12/mit-6583-lab1E/1703596815384-d84cdf32-dd91-44be-b60c-299eb4433c4e.png" class="" title="image.png">
<p>测试通过，但大数据读写效率较低</p>
<hr>
<p><code>buffer_pool_test.go</code></p>
<img src="/2024/01/12/mit-6583-lab1E/1703596871399-7a426e7b-83f9-4411-8ba1-5040d9da8812.png" class="" title="image.png">
<p>测试通过</p>
<h1 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h1><h2 id="Q-2"><a href="#Q-2" class="headerlink" title="Q"></a>Q</h2><blockquote>
<p><code>lab1_query.go</code><br>We have supplied a simple test case for you for this method in lab1_query_test.go, although we will also test it with other files to confirm your implementation is working.</p>
</blockquote>
<p>我们在“lab1_query_test.go”中为此方法提供了一个简单的测试用例，尽管我们还将使用其他文件对其进行测试以确认您的实现正常工作。</p>
<h2 id="computeFieldSum"><a href="#computeFieldSum" class="headerlink" title="computeFieldSum"></a>computeFieldSum</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeFieldSum</span><span class="params">(fileName <span class="type">string</span>, td TupleDesc, sumField <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> some code goes here</span></span><br><span class="line">	<span class="comment">// 打开数据库文件</span></span><br><span class="line">	lab1_bp := <span class="string">&quot;lab1_bp.dat&quot;</span></span><br><span class="line">	<span class="comment">// 如果文件存在，就删除</span></span><br><span class="line">	<span class="keyword">if</span> _, err := os.Stat(lab1_bp); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Remove(lab1_bp)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 新建heapfile，bufferpool为100</span></span><br><span class="line">	hpfile, err := NewHeapFile(lab1_bp, &amp;td, NewBufferPool(<span class="number">100</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打开csv文件，从csv文件中读取数据，写入heapfile</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	err = hpfile.LoadFromCSV(file, <span class="literal">true</span>, <span class="string">&quot;,&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	tid := NewTID()</span><br><span class="line">	<span class="comment">// 开启事务</span></span><br><span class="line">	hpfile.bufPool.BeginTransaction(tid)</span><br><span class="line">	<span class="comment">// 遍历heapfile，计算sum</span></span><br><span class="line">	iter, err := hpfile.Iterator(tid)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		tup, err := iter()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tup == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历tuple，找到sumField</span></span><br><span class="line">		<span class="keyword">for</span> i, field := <span class="keyword">range</span> td.Fields &#123;</span><br><span class="line">			<span class="keyword">if</span> field.Fname == sumField &#123;</span><br><span class="line">				sum += <span class="type">int</span>(tup.Fields[i].(IntField).Value)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回sum</span></span><br><span class="line">	hpfile.bufPool.CommitTransaction(tid)</span><br><span class="line">	<span class="keyword">return</span> sum, <span class="literal">nil</span> <span class="comment">// replace me</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建一个heapFile，指定数据库目录<br>从CSV中加载数据库<br>对数据库进行查询，返回特定Field的sum值</p>
<h2 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h2><p><code>lab1_query_test.go</code></p>
<img src="/2024/01/12/mit-6583-lab1E/1703599178330-43028805-af97-4782-9bf8-cf8b697f2ea3.png" class="" title="image.png">
<p>测试通过</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.icathia.icu">IcathianRain</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.icathia.icu/2024/01/12/mit-6583-lab1E/">https://blog.icathia.icu/2024/01/12/mit-6583-lab1E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.icathia.icu" target="_blank">IcathianRain's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a><a class="post-meta__tags" href="/tags/databases/">databases</a></div><div class="post-share"><div class="social-share" data-image="/images/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/10/18/wwqy/" title="wwqy"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">wwqy</div></div></a><a class="next-post pull-right" href="/2024/01/12/mit-6583-lab1K/" title="mit 6583 lab1K"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mit 6583 lab1K</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2023/12/21/mit-6583-lab0/" title="mit 6.583 lab0"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-21</div><div class="title">mit 6.583 lab0</div></div></a><a href="/2024/01/12/mit-6583-lab1K/" title="mit 6583 lab1K"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-12</div><div class="title">mit 6583 lab1K</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">IcathianRain</div><div class="author-info-description">今夜，我是天选，也是唯一。I was gonna be that one in a million.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Icathian-Rain"><i class="fab fa-github"></i><span>关注</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Icathian-Rain" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/47310416" target="_blank" title="Bilibili"><i class="iconfont icon-bilibili" style="color: #20B0E3;"></i></a><a class="social-icon" href="mailto:2205794866@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercise-1"><span class="toc-text">Exercise 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Q%EF%BC%9A"><span class="toc-text">Q：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TupleDesc"><span class="toc-text">TupleDesc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TupleDesc-equals-%E6%96%B9%E6%B3%95"><span class="toc-text">TupleDesc.equals 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TupleDesc-copy-%E6%96%B9%E6%B3%95"><span class="toc-text">TupleDesc.copy 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TupleDesc-merge-%E6%96%B9%E6%B3%95"><span class="toc-text">TupleDesc.merge 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple"><span class="toc-text">Tuple</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple-writeTo%E6%96%B9%E6%B3%95"><span class="toc-text">Tuple.writeTo方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple-readTupleFrom-%E6%96%B9%E6%B3%95"><span class="toc-text">Tuple.readTupleFrom 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple-equals-%E6%96%B9%E6%B3%95"><span class="toc-text">Tuple.equals 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple-joinTuples-%E6%96%B9%E6%B3%95"><span class="toc-text">Tuple.joinTuples 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple-compareField-%E6%96%B9%E6%B3%95"><span class="toc-text">Tuple.compareField 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple-project-%E6%96%B9%E6%B3%95"><span class="toc-text">Tuple.project 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercise-2"><span class="toc-text">Exercise 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Q"><span class="toc-text">Q:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bufferpool"><span class="toc-text">Bufferpool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bufferpool-FlushAllPages"><span class="toc-text">Bufferpool.FlushAllPages()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bufferpool-GetPage"><span class="toc-text">Bufferpool.GetPage()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercise-3"><span class="toc-text">Exercise 3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-1"><span class="toc-text">Q:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heapPage"><span class="toc-text">heapPage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NumSlots"><span class="toc-text">NumSlots</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insertTuple"><span class="toc-text">insertTuple</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deleteTuple"><span class="toc-text">deleteTuple</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dirty-File"><span class="toc-text">Dirty &amp; File</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toBuffer"><span class="toc-text">toBuffer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initFromBuffer"><span class="toc-text">initFromBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tupleIter"><span class="toc-text">tupleIter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-2"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercise-4"><span class="toc-text">Exercise 4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Q%EF%BC%9A-1"><span class="toc-text">Q：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HeapFile"><span class="toc-text">HeapFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NumPages"><span class="toc-text">NumPages</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#readPage"><span class="toc-text">readPage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flushPage"><span class="toc-text">flushPage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-delete-Tuple"><span class="toc-text">insert &amp; delete Tuple</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Descriptor"><span class="toc-text">Descriptor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator"><span class="toc-text">Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heapHash"><span class="toc-text">heapHash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-3"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercise-5"><span class="toc-text">Exercise 5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-2"><span class="toc-text">Q</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computeFieldSum"><span class="toc-text">computeFieldSum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-4"><span class="toc-text">测试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/18/wwqy/" title="wwqy">wwqy</a><time datetime="2024-10-18T23:22:58.000Z" title="发表于 2024-10-18 23:22:58">2024-10-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/12/mit-6583-lab1E/" title="mit 6583 lab1E">mit 6583 lab1E</a><time datetime="2024-01-12T11:32:40.000Z" title="发表于 2024-01-12 11:32:40">2024-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/12/mit-6583-lab1K/" title="mit 6583 lab1K">mit 6583 lab1K</a><time datetime="2024-01-12T11:30:31.000Z" title="发表于 2024-01-12 11:30:31">2024-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/21/mit-6583-lab0/" title="mit 6.583 lab0">mit 6.583 lab0</a><time datetime="2023-12-21T16:37:00.000Z" title="发表于 2023-12-21 16:37:00">2023-12-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/24/axios-and-fetch/" title="axios and fetch">axios and fetch</a><time datetime="2023-11-24T12:26:37.000Z" title="发表于 2023-11-24 12:26:37">2023-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By IcathianRain</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script> var meting_api='https://api.injahow.cn/meting/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><meting-js server="tencent" type="playlist" id="9070810982" fixed="true" path="https://fqh.yllhwa.com/music/"></meting-js><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>